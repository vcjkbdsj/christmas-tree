<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ å¥¢åé‡‘æ²™åœ£è¯</title>
    <style>
        /* èƒŒæ™¯å‡çº§ï¼šå¸¦æœ‰é‡‘è‰²æš–è°ƒçš„æ·±é‚ƒå¤œç©ºï¼Œè®©é‡‘å±æœ‰ä¸œè¥¿å¯åå°„ */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #332200 0%, #000000 80%); font-family: "Times New Roman", serif; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #title {
            position: absolute; top: 10%; width: 100%; text-align: center;
            color: #ffdd55; font-size: 26px; letter-spacing: 3px; font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 200, 0, 0.8); pointer-events: none; z-index: 10;
        }
        #tips {
            position: absolute; bottom: 8%; width: 100%; text-align: center;
            color: rgba(255, 220, 150, 0.6); pointer-events: none; font-size: 14px; z-index: 10; letter-spacing: 1px;
        }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="title">MERRY CHRISTMAS</div>
    <div id="tips">âœ¨ è½»è§¦å±å¹•èšæ‹¢/æ•£å¼€ | æ»‘åŠ¨é‰´èµ âœ¨</div>
    <div id="canvas-container"></div>

    <script>
        // --- 1. åœºæ™¯ä¸æ‘„å½±æœº ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // æš–é‡‘è‰²é›¾æ°”ï¼Œå¢åŠ è¾‰ç…Œæ„Ÿ
        scene.fog = new THREE.FogExp2(0x221100, 0.02);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 14); 

        // å¼€å¯ç‰©ç†æ­£ç¡®çš„å…‰ç…§æ¨¡å¼
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.physicallyCorrectLights = true; 
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; // å¢åŠ æ›å…‰åº¦ï¼Œæ›´äº®
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // --- 2. å¥¢åç¯å…‰ç³»ç»Ÿ (è§£å†³é»‘å—é—®é¢˜çš„å…³é”®) ---
        
        // ç¯å¢ƒå…‰ï¼šæš–é‡‘è‰²åŸºç¡€ç…§æ˜
        const ambientLight = new THREE.AmbientLight(0xffccaa, 1.5);
        scene.add(ambientLight);

        // ä¸»å…‰ï¼šå¼ºçƒˆæš–é‡‘å°„ç¯ (å³ä¸Šæ–¹)
        const mainLight = new THREE.DirectionalLight(0xffd700, 3.5);
        mainLight.position.set(10, 15, 10);
        mainLight.castShadow = true;
        scene.add(mainLight);

        // è¡¥å…‰1ï¼šåº•éƒ¨å‘ä¸Šç…§çš„é‡‘å…‰ï¼Œç…§äº®ç‰©ä½“åº•éƒ¨
        const bottomLight = new THREE.PointLight(0xffaa00, 2.5, 20);
        bottomLight.position.set(0, -5, 2);
        scene.add(bottomLight);
        
        // è¡¥å…‰2ï¼šä¾§é¢å†·å…‰å¢åŠ å¯¹æ¯”åº¦ï¼Œè®©é‡‘è‰²æ›´æœ‰è´¨æ„Ÿ
        const rimLight = new THREE.PointLight(0x8888ff, 2.0, 20);
        rimLight.position.set(-8, 5, -5);
        scene.add(rimLight);


        // --- 3. ä¸°å¯Œçš„æè´¨åº“ ---
        const mats = [
            // é•œé¢è€€çœ¼é‡‘ (æé«˜åå°„)
            new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.05, emissive: 0x221100 }),
            // ç£¨ç ‚è´¨æ„Ÿé‡‘ (è¾ƒç²—ç³™)
            new THREE.MeshStandardMaterial({ color: 0xffcc33, metalness: 0.8, roughness: 0.35 }),
            // çº¢å®çŸ³é‡‘å± (æ·±çº¢åå°„)
            new THREE.MeshStandardMaterial({ color: 0xdd0033, metalness: 0.7, roughness: 0.2, emissive: 0x330000 })
        ];

        // --- 4. ä¸°å¯Œçš„å½¢çŠ¶åº“ ---
        const geos = [
            new THREE.BoxGeometry(0.9, 0.9, 0.9), // ç¤¼ç‰©ç›’
            new THREE.SphereGeometry(0.65, 24, 24), // åœ†æ¶¦é‡‘çƒ
            new THREE.IcosahedronGeometry(0.7, 0), // å®çŸ³ (å¤šé¢)
            new THREE.OctahedronGeometry(0.75, 0), // é’»çŸ³ (å°–é”)
            new THREE.TorusGeometry(0.5, 0.25, 12, 24) // é‡‘ç¯/ç”œç”œåœˆ
        ];

        // --- 5. åˆ›å»ºç²’å­ä¸»ä½“ ---
        const decosGroup = new THREE.Group();
        scene.add(decosGroup);
        const allDecos = []; 
        const totalDecos = 666; // å‰åˆ©æ•°å­—

        for (let i = 0; i < totalDecos; i++) {
            // ã€å…³é”®ã€‘éšæœºé€‰æ‹©å½¢çŠ¶å’Œæè´¨
            const randomGeo = geos[Math.floor(Math.random() * geos.length)];
            const randomMat = mats[Math.floor(Math.random() * mats.length)];
            
            const mesh = new THREE.Mesh(randomGeo, randomMat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // éšæœºå¾®è°ƒå¤§å°
            const s = Math.random() * 0.4 + 0.6;
            mesh.scale.set(s,s,s);

            // --- ä½ç½®ç®—æ³• (ä¿æŒä¸å˜) ---
            // A. æ ‘å½¢æ€
            const p = i / totalDecos; 
            const angle = p * Math.PI * 26 + i * 0.05; 
            const radius = (1 - p) * 4.8 + Math.random()*0.3; 
            const y = p * 10 - 5; 
            mesh.userData.posTree = new THREE.Vector3(Math.cos(angle)*radius, y, Math.sin(angle)*radius);

            // B. æ•£å¼€å½¢æ€
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 7 + Math.random() * 9; 
            mesh.userData.posExplode = new THREE.Vector3(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
            
            mesh.userData.rotSpeed = { x: Math.random()*0.03, y: Math.random()*0.03, z: Math.random()*0.03 };
            mesh.position.copy(mesh.userData.posExplode); // åˆå§‹çŠ¶æ€ï¼šæ•£å¼€
            
            decosGroup.add(mesh);
            allDecos.push(mesh);
        }

        // é¡¶éƒ¨è¶…çº§å¤§é’»çŸ³
        const topStar = new THREE.Mesh(
            new THREE.OctahedronGeometry(1.2, 0),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.9, roughness: 0, emissive: 0x555522, transparent: true, opacity: 0.9 })
        );
        topStar.userData.posTree = new THREE.Vector3(0, 5.8, 0);
        topStar.userData.posExplode = new THREE.Vector3(0, 14, 0);
        topStar.position.copy(topStar.userData.posExplode);
        decosGroup.add(topStar);
        allDecos.push(topStar);

        // --- 6. äº¤äº’ä¸åŠ¨ç”» ---
        let isTreeForm = false;
        let progress = 0;

        function toggleState() { isTreeForm = !isTreeForm; }
        window.addEventListener('click', toggleState);
        window.addEventListener('touchstart', (e) => { if(e.touches.length === 1) toggleState(); }, {passive: false});

        let targetRotY = 0; let lastX = 0;
        window.addEventListener('touchmove', (e) => { targetRotY += (e.touches[0].clientX - lastX) * 0.006; lastX = e.touches[0].clientX; });
        window.addEventListener('touchstart', (e) => { lastX = e.touches[0].clientX; });

        function animate() {
            requestAnimationFrame(animate);
            const target = isTreeForm ? 1 : 0;
            progress += (target - progress) * 0.04; // ç¼“åŠ¨

            allDecos.forEach(mesh => {
                mesh.position.lerpVectors(mesh.userData.posExplode, mesh.userData.posTree, progress);
                mesh.rotation.x += mesh.userData.rotSpeed.x;
                mesh.rotation.y += mesh.userData.rotSpeed.y;
                mesh.rotation.z += mesh.userData.rotSpeed.z;
            });

            topStar.rotation.y += 0.02; // é¡¶éƒ¨é’»çŸ³ç‹¬ç«‹æ—‹è½¬
            decosGroup.rotation.y += 0.002; // è‡ªåŠ¨æ…¢è½¬
            decosGroup.rotation.y += (targetRotY - decosGroup.rotation.y) * 0.05; // æ‰‹åŠ¨è·Ÿéš

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
