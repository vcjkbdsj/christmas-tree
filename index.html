<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ MERRY CHRISTMAS</title>
    <style>
        /* èƒŒæ™¯ï¼šæ·±é‚ƒå¤œç©º */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #111 0%, #000 100%); font-family: "Times New Roman", serif; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ–‡å­—å±‚çº§è¦é«˜ï¼Œç¡®ä¿ä¸è¢«é®æŒ¡ */
        #title {
            position: absolute; top: 10%; width: 100%; text-align: center;
            color: #ffcc00; font-size: 28px; letter-spacing: 4px; font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); pointer-events: none; z-index: 10;
        }
        #tips {
            position: absolute; bottom: 8%; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.5); pointer-events: none; font-size: 14px; z-index: 10;
        }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="title">MERRY CHRISTMAS</div>
    <div id="tips">è½»è§¦å±å¹•èšæ‹¢/æ•£å¼€ | æ»‘åŠ¨æ—‹è½¬</div>
    <div id="canvas-container"></div>

    <script>
        // --- 1. åœºæ™¯è®¾ç½® ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); // é»‘è‰²é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 13); // åˆå§‹ç›¸æœºä½ç½®

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
        container.appendChild(renderer.domElement);

        // --- 2. ç¯å…‰ç³»ç»Ÿ (è¥é€ é‡‘ç¢§è¾‰ç…Œçš„æ„Ÿè§‰) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // ä¸»é‡‘å…‰
        const dirLight = new THREE.DirectionalLight(0xffd700, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // ä¾§é¢è¡¥å…‰ (è“è‰²è°ƒï¼Œå½¢æˆå†·æš–å¯¹æ¯”)
        const pointLight = new THREE.PointLight(0x4444ff, 0.8, 20);
        pointLight.position.set(-5, 0, -5);
        scene.add(pointLight);

        // --- 3. æè´¨ ---
        // é«˜å…‰é»„é‡‘æè´¨
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: 0xffcc00, 
            metalness: 1.0, 
            roughness: 0.2,
            envMapIntensity: 1.0 
        });
        // ç£¨ç ‚çº¢çƒæè´¨
        const redMat = new THREE.MeshStandardMaterial({ 
            color: 0xaa0000, 
            metalness: 0.6, 
            roughness: 0.4 
        });

        // --- 4. åˆ›å»ºç²’å­æ ‘ä¸»ä½“ ---
        const decosGroup = new THREE.Group(); // ç»„åå®šä¹‰
        scene.add(decosGroup);

        const allDecos = []; 
        const totalDecos = 600; // ç²’å­æ•°é‡

        // å¤ç”¨å‡ ä½•ä½“ä¼˜åŒ–æ€§èƒ½
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const sphereGeo = new THREE.SphereGeometry(0.6, 16, 16);

        for (let i = 0; i < totalDecos; i++) {
            let mesh;
            // 80% æ˜¯é‡‘è‰²æ–¹å—(æ¨¡æ‹Ÿç¤¼ç‰©ç›’/é‡‘ç –)ï¼Œ20% æ˜¯çº¢è‰²çƒ
            if (Math.random() > 0.2) {
                mesh = new THREE.Mesh(boxGeo, goldMat);
                // éšæœºæ‹‰ä¼¸ä¸€ç‚¹ï¼Œåƒé•¿æ–¹ä½“ç¤¼ç‰©ç›’
                mesh.scale.set(Math.random()*0.3+0.1, Math.random()*0.3+0.1, Math.random()*0.3+0.1);
            } else {
                mesh = new THREE.Mesh(sphereGeo, redMat);
                const s = Math.random()*0.3 + 0.2;
                mesh.scale.set(s, s, s);
            }

            // --- æ ¸å¿ƒç®—æ³•ï¼šè®¡ç®—â€œæ ‘å½¢æ€â€å’Œâ€œæ•£å¼€å½¢æ€â€çš„åæ ‡ ---
            
            // A. æ ‘å½¢æ€ (åœ†é”¥èºæ—‹)
            const p = i / totalDecos; // 0 (åº•) -> 1 (é¡¶)
            const angle = p * Math.PI * 25 + i * 0.1; // èºæ—‹
            const radius = (1 - p) * 4.5; // ä¸‹é¢å®½ä¸Šé¢çª„
            const y = p * 9 - 4.5; // é«˜åº¦åˆ†å¸ƒ
            
            // å­˜å…¥è‡ªå®šä¹‰æ•°æ®
            mesh.userData.posTree = new THREE.Vector3(
                Math.cos(angle) * radius,
                y,
                Math.sin(angle) * radius
            );

            // B. æ•£å¼€å½¢æ€ (éšæœºçˆ†ç‚¸)
            // ä½¿ç”¨çƒåæ ‡éšæœºåˆ†å¸ƒ
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 6 + Math.random() * 8; // åŠå¾„ 6-14
            
            mesh.userData.posExplode = new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            
            // éšæœºè‡ªè½¬é€Ÿåº¦
            mesh.userData.rotSpeed = {
                x: Math.random() * 0.02,
                y: Math.random() * 0.02
            };

            // åˆå§‹ä½ç½®ï¼šå…ˆè®¾ç½®ä¸ºæ•£å¼€
            mesh.position.copy(mesh.userData.posExplode);
            
            decosGroup.add(mesh); // ã€ä¿®æ­£ç‚¹ã€‘è¿™é‡Œä¹‹å‰å†™é”™äº†å˜é‡å
            allDecos.push(mesh);
        }

        // é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ
        const star = new THREE.Mesh(
            new THREE.OctahedronGeometry(0.5, 0),
            new THREE.MeshBasicMaterial({ color: 0xffffaa })
        );
        star.userData.posTree = new THREE.Vector3(0, 5, 0);
        star.userData.posExplode = new THREE.Vector3(0, 12, 0);
        star.position.copy(star.userData.posExplode);
        decosGroup.add(star);
        allDecos.push(star);

        // --- 5. äº¤äº’é€»è¾‘ ---
        let isTreeForm = false; // å½“å‰çŠ¶æ€ï¼šfalse=æ•£å¼€, true=æ ‘
        let progress = 0; // åŠ¨ç”»è¿›åº¦ 0 -> 1

        // ç‚¹å‡»/è§¦æ‘¸è§¦å‘åˆ‡æ¢
        function toggleState() {
            isTreeForm = !isTreeForm;
        }
        window.addEventListener('click', toggleState);
        window.addEventListener('touchstart', (e) => {
            // ç®€å•çš„è§¦æ‘¸é˜²æŠ–
            if(e.touches.length === 1) toggleState();
        }, {passive: false});

        // è§¦æ‘¸æ»‘åŠ¨æ—‹è½¬
        let targetRotY = 0;
        let lastX = 0;
        window.addEventListener('touchmove', (e) => {
            const currentX = e.touches[0].clientX;
            const deltaX = currentX - lastX;
            targetRotY += deltaX * 0.005;
            lastX = currentX;
        });
        window.addEventListener('touchstart', (e) => {
            lastX = e.touches[0].clientX;
        });

        // --- 6. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // çŠ¶æ€æ’å€¼ï¼šç›®æ ‡å€¼æ˜¯ 1(æ ‘) æˆ– 0(æ•£å¼€)
            const target = isTreeForm ? 1 : 0;
            // ç¼“åŠ¨å…¬å¼ï¼šè®© progress æ…¢æ…¢æ¥è¿‘ target
            progress += (target - progress) * 0.03;

            // æ›´æ–°æ¯ä¸ªç‰©ä½“çš„ä½ç½®
            allDecos.forEach(mesh => {
                // åˆ©ç”¨ lerp åœ¨ä¸¤ä¸ªçŠ¶æ€é—´è¿‡æ¸¡
                mesh.position.lerpVectors(mesh.userData.posExplode, mesh.userData.posTree, progress);
                
                // æŒç»­è‡ªè½¬
                mesh.rotation.x += mesh.userData.rotSpeed?.x || 0.01;
                mesh.rotation.y += mesh.userData.rotSpeed?.y || 0.01;
            });

            // æ•´ä½“æ—‹è½¬ (è‡ªåŠ¨ + æ‰‹åŠ¨)
            decosGroup.rotation.y += 0.002; // è‡ªåŠ¨æ…¢è½¬
            decosGroup.rotation.y += (targetRotY - decosGroup.rotation.y) * 0.05; // æ‰‹åŠ¨è·Ÿéš

            renderer.render(scene, camera);
        }
        animate();

        // é€‚é…çª—å£
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
