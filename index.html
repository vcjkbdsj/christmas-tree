<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ MERRY CHRISTMAS</title>
    <style>
        /* èƒŒæ™¯ä½¿ç”¨æ·±é‚ƒçš„è“é»‘æ¸å˜ï¼Œæ¨¡ä»¿å¤œç©º */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #1a1a3a 0%, #000000 100%); font-family: "Times New Roman", serif; }
        #canvas-container { width: 100%; height: 100%; }
        
        /* é¡¶éƒ¨é‡‘è‰²æ–‡å­— */
        #title {
            position: absolute; top: 8%; width: 100%; text-align: center;
            color: #ffd700; font-size: 24px; letter-spacing: 3px; font-weight: bold;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5); pointer-events: none;
            font-family: 'Times New Roman', Times, serif;
        }
        /* åº•éƒ¨æ“ä½œæç¤º */
        #tips {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: rgba(255, 215, 0, 0.6); pointer-events: none; font-size: 14px; letter-spacing: 1px;
        }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="title">MERRY CHRISTMAS</div>
    <div id="tips">è½»è§¦å±å¹•èšé›†/æ•£å¼€ | æ»‘åŠ¨æ—‹è½¬</div>
    <div id="canvas-container"></div>

    <script>
        // Let's do this! è¿˜åŸé‚£ä¸ªé…·ç‚«çš„æ•ˆæœã€‚

        // --- 1. åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // æ·»åŠ å°‘è®¸ç¯å¢ƒé›¾æ°”ï¼Œå¢åŠ æ·±åº¦æ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        let targetPositionZ = 12; camera.position.z = targetPositionZ; camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // å¼€å¯é˜´å½±æ”¯æŒï¼Œæ›´æœ‰ç«‹ä½“æ„Ÿ
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // --- 2. ç¯å…‰ç³»ç»Ÿ (è®©é‡‘å±çƒé—ªé—ªå‘å…‰) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // ä¸»å…‰æºï¼ˆæš–é‡‘è‰²ï¼‰
        const mainLight = new THREE.PointLight(0xffd700, 1.5, 30);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        scene.add(mainLight);
        
        // è¡¥å…‰ï¼ˆå†·è‰²è°ƒï¼Œå¢åŠ å¯¹æ¯”ï¼‰
        const fillLight = new THREE.PointLight(0x4444ff, 0.8, 20);
        fillLight.position.set(-5, 2, -5);
        scene.add(fillLight);

        // --- 3. æè´¨å‡†å¤‡ ---
        // é‡‘è‰²é‡‘å±æè´¨
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });
        // çº¢è‰²é‡‘å±æè´¨
        const redMat = new THREE.MeshStandardMaterial({ color: 0xdd0000, metalness: 0.8, roughness: 0.2 });
        // é¡¶éƒ¨é’»çŸ³æè´¨ (å‘å…‰)
        const diamondMat = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x333300, shininess: 100, transparent: true, opacity: 0.9 });

        // --- 4. åˆ›å»ºè£…é¥°å“å¯¹è±¡ ---
        const decosGroup = new THREE.Group();
        scene.add(decosGroup);
        const allDecos = []; // å­˜æ”¾æ‰€æœ‰è£…é¥°å“çš„æ•°ç»„

        // å‡ ä½•ä½“å¤ç”¨
        const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        
        const totalDecos = 500; // è£…é¥°å“æ€»æ•°

        for (let i = 0; i < totalDecos; i++) {
            let mesh;
            // éšæœºç»„åˆï¼š70%æ˜¯çƒï¼Œ30%æ˜¯ç¤¼ç‰©ç›’
            if (Math.random() > 0.3) {
                // çƒä½“ï¼Œéšæœºåˆ†é…é‡‘/çº¢æè´¨
                mesh = new THREE.Mesh(sphereGeo, Math.random() > 0.5 ? goldMat : redMat);
                const scale = Math.random() * 0.2 + 0.1; // å¤§å°éšæœº
                mesh.scale.set(scale, scale, scale);
            } else {
                // ç¤¼ç‰©ç›’
                mesh = new THREE.Mesh(boxGeo, Math.random() > 0.5 ? goldMat : redMat);
                const scale = Math.random() * 0.25 + 0.15;
                mesh.scale.set(scale, scale, scale);
                mesh.rotation.set(Math.random(), Math.random(), Math.random()); // éšæœºè§’åº¦
            }
            mesh.castShadow = true;

            // --- å…³é”®ï¼šè®¡ç®—ä¸¤ä¸ªä½ç½® ---

            // A. æ ‘å½¢æ€çš„ä½ç½® (åœ†é”¥èºæ—‹)
            const progress = i / totalDecos; // 0 åˆ° 1ï¼Œè¡¨ç¤ºä»æ ‘åº•åˆ°æ ‘é¡¶
            const angle = progress * Math.PI * 20 + Math.random(); // èºæ—‹è§’åº¦
            // åŠå¾„éšé«˜åº¦å˜å°ï¼Œåº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const radius = (1 - progress) * 4.0 + 0.2; 
            const treeY = progress * 8 - 4; // é«˜åº¦èŒƒå›´ -4 åˆ° 4
            const treeX = Math.cos(angle) * radius;
            const treeZ = Math.sin(angle) * radius;
            // å°†è®¡ç®—å‡ºçš„æ ‘ä½ç½®å­˜åœ¨å¯¹è±¡æ•°æ®é‡Œ
            mesh.userData.posTree = new THREE.Vector3(treeX, treeY, treeZ);

            // B. æ•£å¼€å½¢æ€çš„ä½ç½® (éšæœºçƒä½“äº‘)
            const randAngle = Math.random() * Math.PI * 2;
            const randPhi = Math.acos(2 * Math.random() - 1);
            const randR = 5 + Math.random() * 6; // æ•£å¼€åŠå¾„ 5-11
            mesh.userData.posRandom = new THREE.Vector3(
                randR * Math.sin(randPhi) * Math.cos(randAngle),
                randR * Math.sin(randPhi) * Math.sin(randAngle) + 2, //ç¨å¾®æŠ¬é«˜ä¸€ç‚¹
                randR * Math.cos(randPhi)
            );

            // åˆå§‹çŠ¶æ€ï¼šå…ˆè®¾ç½®åœ¨éšæœºä½ç½® (æ•£å¼€çŠ¶æ€)
            mesh.position.copy(mesh.userData.posRandom);
            
            // ç»™æ¯ä¸ªç‰©ä½“ä¸€ä¸ªéšæœºçš„è‡ªè½¬é€Ÿåº¦ï¼Œæ›´ç”ŸåŠ¨
            mesh.userData.rotateSpeed = {
                x: (Math.random()-0.5)*0.02,
                y: (Math.random()-0.5)*0.02,
                z: (Math.random()-0.5)*0.02
            };

            decGroup.add(mesh);
            allDecos.push(mesh);
        }

        // --- 5. é¡¶éƒ¨å¤§é’»çŸ³/æ˜Ÿæ˜Ÿ ---
        const topDiamond = new THREE.Mesh(new THREE.OctahedronGeometry(0.5), diamondMat);
        // å®ƒçš„æ ‘ä½ç½®åœ¨æœ€é¡¶ç«¯ï¼Œéšæœºä½ç½®åœ¨æ›´é«˜å¤„
        topDiamond.userData.posTree = new THREE.Vector3(0, 4.5, 0);
        topDiamond.userData.posRandom = new THREE.Vector3(0, 10, 0);
        topDiamond.position.copy(topDiamond.userData.posRandom); // åˆå§‹åœ¨ä¸Šé¢
        decosGroup.add(topDiamond);
        allDecos.push(topDiamond); // æŠŠå®ƒä¹ŸåŠ å…¥åŠ¨ç”»é˜Ÿåˆ—

        // --- 6. äº¤äº’é€»è¾‘ ---
        
        // åŠ¨ç”»çŠ¶æ€æ§åˆ¶
        let isFormed = false; // å½“å‰æ˜¯ä¸æ˜¯æ ‘çš„å½¢æ€
        let currentProgress = 0; // 0 = å®Œå…¨æ•£å¼€, 1 = å®Œå…¨æˆæ ‘
        let targetProgress = 0;  // ç›®æ ‡çŠ¶æ€

        // ç‚¹å‡»å±å¹•åˆ‡æ¢çŠ¶æ€
        document.addEventListener('click', () => {
            isFormed = !isFormed;
            targetProgress = isFormed ? 1 : 0; // åˆ‡æ¢ç›®æ ‡å€¼
            // æ·»åŠ ä¸€ç‚¹ç‚¹å‡»æ—¶çš„éœ‡åŠ¨åé¦ˆ (å¯é€‰ï¼Œè§†è§‰ä¸Šçš„)
            decosGroup.scale.setScalar(0.95);
            setTimeout(()=> decosGroup.scale.setScalar(1), 100);
        });
        // å…¼å®¹ç§»åŠ¨ç«¯è§¦æ‘¸
        document.addEventListener('touchstart', (e) => {
             // å¦‚æœä¸æ˜¯æ»‘åŠ¨æ“ä½œæ‰è§¦å‘ç‚¹å‡» (ç®€å•åˆ¤æ–­)
            if(e.touches.length === 1) {
                isFormed = !isFormed;
                targetProgress = isFormed ? 1 : 0;
            }
        }, {passive: true});


        // é•œå¤´æ§åˆ¶ (æ»‘åŠ¨æ—‹è½¬ç¼©æ”¾ï¼Œæ²¿ç”¨ä¹‹å‰çš„é€»è¾‘)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotationY = 0;
        let targetRotationX = 0; // å¢åŠ ä¸Šä¸‹è§†è§’

        document.addEventListener('touchmove', onTouchMove, {passive: false});
        document.addEventListener('touchstart', (e) => { isDragging = true; previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };}, {passive: true});
        document.addEventListener('touchend', () => { isDragging = false; });

        function onTouchMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            // é™åˆ¶ä¸Šä¸‹è§†è§’
            targetRotationX = Math.max(-0.5, Math.min(0.5, targetRotationX));
            
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        // --- 7. æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);

            // A. çŠ¶æ€å¹³æ»‘è¿‡æ¸¡ (æ’å€¼åŠ¨ç”»æ ¸å¿ƒ)
            // è®© currentProgress ç¼“æ…¢æ¥è¿‘ targetProgressï¼Œå®ç°å¹³æ»‘ç§»åŠ¨
            currentProgress += (targetProgress - currentProgress) * 0.04;

            // B. æ›´æ–°æ¯ä¸€ä¸ªè£…é¥°å“çš„ä½ç½®
            allDecos.forEach(mesh => {
                // ä½¿ç”¨ lerpVectors åœ¨éšæœºä½ç½®å’Œæ ‘ä½ç½®ä¹‹é—´æ’å€¼
                // currentProgress ä¸º 0 æ—¶åœ¨ posRandomï¼Œä¸º 1 æ—¶åœ¨ posTree
                mesh.position.lerpVectors(mesh.userData.posRandom, mesh.userData.posTree, currentProgress);
                
                // è®©å®ƒä»¬ä¿æŒç¼“æ…¢è‡ªè½¬
                mesh.rotation.x += mesh.userData.rotateSpeed.x;
                mesh.rotation.y += mesh.userData.rotateSpeed.y;
                mesh.rotation.z += mesh.userData.rotateSpeed.z;
            });

            // C. é¡¶éƒ¨é’»çŸ³é¢å¤–åŠ¨ç”»
            topDiamond.rotation.y += 0.02;

            // D. é•œå¤´æ§åˆ¶å¹³æ»‘è¿‡æ¸¡
            decosGroup.rotation.y += (targetRotationY - decosGroup.rotation.y) * 0.05;
            decosGroup.rotation.x += (targetRotationX - decosGroup.rotation.x) * 0.05;
            
            // ç¼“æ…¢çš„è‡ªåŠ¨å±•ç¤ºæ—‹è½¬
            targetRotationY += 0.001;

            renderer.render(scene, camera);
        }
        animate();

        // çª—å£è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
