<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ åœ£è¯å¿«ä¹</title>
    <style>
        /* å¼ºåˆ¶èƒŒæ™¯ä¸ºæ·±è‰²ï¼Œé˜²æ­¢ç™½å± */
        html, body { 
            margin: 0; 
            overflow: hidden; 
            width: 100%; 
            height: 100%; 
            background-color: #000; 
            background: radial-gradient(circle at center, #1a1000 0%, #000000 100%); 
            font-family: "Times New Roman", serif; 
        }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #title {
            position: absolute; top: 12%; width: 100%; text-align: center;
            color: #ffd700; font-size: 24px; letter-spacing: 4px; font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6); pointer-events: none; z-index: 10;
        }
        #tips {
            position: absolute; bottom: 8%; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.6); pointer-events: none; font-size: 14px; z-index: 10;
            text-shadow: 0 0 2px #000;
        }
    </style>
    <script src="https://lib.baomitu.com/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="title">MERRY CHRISTMAS</div>
    <div id="tips">âœ¨ ç‚¹å‡»å±å¹•èšæ‹¢/æ•£å¼€ | æ»‘åŠ¨æ—‹è½¬ âœ¨</div>
    <div id="canvas-container"></div>

    <script>
        // 1. åˆå§‹åŒ–åœºæ™¯
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 14);

        // ã€ä¿®å¤ç‚¹ã€‘è¿™é‡ŒåŠ ä¸Šäº† constï¼Œé˜²æ­¢æŠ¥é”™
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
        container.appendChild(renderer.domElement);

        // 2. ç¯å…‰è®¾ç½® (é‡‘å…‰é—ªé—ªçš„å…³é”®)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffaa00, 2.0);
        dirLight.position.set(10, 10, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        const pointLight = new THREE.PointLight(0xffd700, 1.5, 15);
        pointLight.position.set(0, 5, 5);
        scene.add(pointLight);

        // 3. æè´¨å‡†å¤‡
        // äº®é‡‘
        const goldMat = new THREE.MeshStandardMaterial({ 
            color: 0xffcc00, 
            metalness: 0.9, 
            roughness: 0.1,
            emissive: 0x111100
        });
        // ç£¨ç ‚çº¢
        const redMat = new THREE.MeshStandardMaterial({ 
            color: 0xaa0000, 
            metalness: 0.6, 
            roughness: 0.4 
        });

        // 4. åˆ›å»ºè£…é¥°å“ç»„
        const group = new THREE.Group();
        scene.add(group);

        const allMesh = [];
        const count = 550; // ç²’å­æ•°é‡

        const boxGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const sphereGeo = new THREE.SphereGeometry(0.5, 16, 16);

        for(let i=0; i<count; i++) {
            // éšæœºé€‰æ‹©å½¢çŠ¶å’Œæè´¨
            let mesh;
            if(Math.random() > 0.25) {
                mesh = new THREE.Mesh(boxGeo, goldMat);
            } else {
                mesh = new THREE.Mesh(sphereGeo, redMat);
            }
            
            // éšæœºå¤§å°
            const s = Math.random() * 0.5 + 0.3;
            mesh.scale.set(s,s,s);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // --- ä½ç½®è®¡ç®— ---
            
            // A. æ•£å¼€ä½ç½® (éšæœºç‚¸å¼€)
            const range = 10;
            const xRand = (Math.random()-0.5) * range * 2.5;
            const yRand = (Math.random()-0.5) * range * 2.5;
            const zRand = (Math.random()-0.5) * range * 1.5;
            mesh.userData.posOpen = new THREE.Vector3(xRand, yRand, zRand);

            // B. èšæ‹¢ä½ç½® (åœ£è¯æ ‘å½¢æ€)
            const p = i / count; // 0åˆ°1
            const angle = p * Math.PI * 24 + i * 0.1;
            const radius = (1 - p) * 5.0; // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨å°–
            const yTree = p * 10 - 5;
            const xTree = Math.cos(angle) * radius;
            const zTree = Math.sin(angle) * radius;
            mesh.userData.posTree = new THREE.Vector3(xTree, yTree, zTree);

            // åˆå§‹è®¾ä¸ºæ•£å¼€
            mesh.position.copy(mesh.userData.posOpen);
            
            // éšæœºè‡ªè½¬
            mesh.userData.rotSpeed = {
                x: Math.random() * 0.02,
                y: Math.random() * 0.02
            };

            group.add(mesh);
            allMesh.push(mesh);
        }

        // é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ
        const star = new THREE.Mesh(
            new THREE.OctahedronGeometry(1.0, 0),
            new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x444400, metalness: 0.8 })
        );
        star.userData.posTree = new THREE.Vector3(0, 5.5, 0);
        star.userData.posOpen = new THREE.Vector3(0, 12, 0);
        star.position.copy(star.userData.posOpen);
        group.add(star);
        allMesh.push(star);

        // 5. äº¤äº’é€»è¾‘
        let isTree = false; // å½“å‰æ˜¯ä¸æ˜¯æ ‘
        let progress = 0;   // åŠ¨ç”»è¿›åº¦

        // ç‚¹å‡»åˆ‡æ¢
        function toggle() {
            isTree = !isTree;
        }
        
        // å…¼å®¹è§¦æ‘¸å’Œç‚¹å‡»
        window.addEventListener('click', toggle);
        window.addEventListener('touchstart', (e) => {
             // ç®€å•çš„è§¦æ‘¸å¤„ç†ï¼Œé˜²æ­¢ä¸æ»‘åŠ¨å†²çª
             if(e.changedTouches.length === 1 && Math.abs(e.changedTouches[0].clientX - lastX) < 5) {
                 toggle();
             }
        });

        // æ»‘åŠ¨æ—‹è½¬
        let lastX = 0;
        let targetRotY = 0;
        
        window.addEventListener('touchstart', (e) => {
            lastX = e.touches[0].clientX;
        });
        
        window.addEventListener('touchmove', (e) => {
            const currentX = e.touches[0].clientX;
            const delta = currentX - lastX;
            targetRotY += delta * 0.01; // æ—‹è½¬çµæ•åº¦
            lastX = currentX;
            e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
        }, { passive: false });

        // 6. åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            // ç¼“åŠ¨åˆ‡æ¢
            const target = isTree ? 1 : 0;
            progress += (target - progress) * 0.05;

            // æ›´æ–°æ¯ä¸ªç‚¹
            allMesh.forEach(m => {
                m.position.lerpVectors(m.userData.posOpen, m.userData.posTree, progress);
                m.rotation.x += m.userData.rotSpeed.x;
                m.rotation.y += m.userData.rotSpeed.y;
            });

            // æ—‹è½¬åœºæ™¯
            group.rotation.y += 0.002; // è‡ªåŠ¨å¾®è½¬
            group.rotation.y += (targetRotY - group.rotation.y) * 0.1; // è·Ÿéšæ‰‹æŒ‡

            renderer.render(scene, camera);
        }
        animate();

        // çª—å£é€‚é…
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
