<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>✨ 梦幻粒子圣诞树</title>
    <style>
        /* 背景使用深邃的渐变色 */
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #0a0a2a 0%, #000000 100%); font-family: sans-serif; }
        #canvas-container { width: 100%; height: 100%; }
        #tips {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: rgba(100, 255, 218, 0.8); pointer-events: none; font-size: 15px; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5); animation: pulse 3s infinite ease-in-out;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.05); } }
    </style>
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="tips">滑动指尖 点亮星辰</div>
    <div id="canvas-container"></div>

    <script>
        // --- 1. 初始化场景 ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 去掉雾气，让粒子更通透
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // 相机初始位置
        let targetPositionZ = 6; camera.position.z = targetPositionZ; camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // 【关键】开启叠加混合模式支持，让粒子发光
        renderer.autoClearColor = false;
        container.appendChild(renderer.domElement);

        const mainGroup = new THREE.Group();
        scene.add(mainGroup);

        // --- 2. 核心：生成粒子树 ---
        
        // 函数：创建一个粒子系统
        function createParticleSystem(count, color, size, blendingOpts, shapeFn) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                const coords = shapeFn(i, count);
                positions[i * 3] = coords.x;
                positions[i * 3 + 1] = coords.y;
                positions[i * 3 + 2] = coords.z;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: 0.8,
                // 【关键】叠加混合，让粒子重叠发光
                blending: blendingOpts ? THREE.AdditiveBlending : THREE.NormalBlending,
                depthWrite: false // 防止粒子互相遮挡出现黑边
            });
            
            return new THREE.Points(geometry, material);
        }

        // A. 树的主体粒子 (青绿色，螺旋上升)
        const treeParticles = createParticleSystem(3500, 0x00ffaa, 0.06, true, (i, count) => {
            // 进度 0 (底端) -> 1 (顶端)
            const progress = i / count; 
            // 角度：越往上旋转越快
            const angle = progress * Math.PI * 25; 
            // 半径：越往上越小，形成圆锥，并加入随机杂色让它看起来自然
            const radius = (1 - progress) * 3.0 + (Math.random() - 0.5) * 0.4;
            
            const x = Math.cos(angle) * radius;
            // 高度拉伸一下
            const y = progress * 6 - 2.5; 
            const z = Math.sin(angle) * radius;
            return {x, y, z};
        });
        mainGroup.add(treeParticles);

        // B. 装饰彩灯粒子 (红/金混合，更大，更散)
        const ornamentParticles = createParticleSystem(300, 0xff3300, 0.15, true, (i, count) => {
            const progress = Math.random(); // 完全随机分布
            const angle = Math.random() * Math.PI * 2;
            // 半径比树叶稍大一点，浮在表面
            const radius = (1 - progress) * 3.2 * Math.random();
            const x = Math.cos(angle) * radius;
            const y = progress * 5.5 - 2.5;
            const z = Math.sin(angle) * radius;
            return {x, y, z};
        });
        // 给装饰粒子换个随机色
        const colors = new Float32Array(300 * 3);
        const colorPalette = [new THREE.Color(0xff0000), new THREE.Color(0xffd700), new THREE.Color(0xffffff)];
        for(let i=0; i<300; i++) {
            const col = colorPalette[Math.floor(Math.random() * colorPalette.length)];
            colors[i*3] = col.r; colors[i*3+1] = col.g; colors[i*3+2] = col.b;
        }
        ornamentParticles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        ornamentParticles.material.vertexColors = true; // 启用顶点颜色
        ornamentParticles.material.color = new THREE.Color(0xffffff); // 重置基础色
        mainGroup.add(ornamentParticles);

        // C. 顶部的粒子星星
        const starParticles = createParticleSystem(50, 0xffffcc, 0.2, true, (i, count) => {
            // 球形分布
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 0.3 * Math.cbrt(Math.random()); // 半径更小，聚集在一起
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta) + 3.6, // 放在顶部
                z: r * Math.cos(phi)
            };
        });
        mainGroup.add(starParticles);
        
        // --- 3. 交互逻辑 (触屏滑动) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotationY = 0;

        document.addEventListener('touchstart', onTouchStart, {passive: false});
        document.addEventListener('touchmove', onTouchMove, {passive: false});
        document.addEventListener('touchend', () => { isDragging = false; });

        function onTouchStart(e) {
            isDragging = true;
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function onTouchMove(e) {
            if (!isDragging) return;
            e.preventDefault(); 
            const deltaX = e.touches[0].clientX - previousMousePosition.x;
            const deltaY = e.touches[0].clientY - previousMousePosition.y;
            // 左右滑动 -> 旋转
            targetRotationY += deltaX * 0.008;
            // 上下滑动 -> 缩放 (改变相机距离)
            targetPositionZ += deltaY * 0.02;
            // 限制缩放范围
            targetPositionZ = Math.max(3, Math.min(12, targetPositionZ));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        // --- 4. 动画循环 ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // 平滑旋转和缩放
            mainGroup.rotation.y += (targetRotationY - mainGroup.rotation.y) * 0.05;
            camera.position.z += (targetPositionZ - camera.position.z) * 0.1;
            camera.lookAt(0, 1, 0); // 确保相机看着树中心

            // 缓慢自转
            mainGroup.rotation.y += 0.002;

            // 让粒子闪烁动起来 (修改顶点位置)
            const treePositions = treeParticles.geometry.attributes.position.array;
            for(let i=0; i < treePositions.length / 3; i++) {
                // 简单的上下浮动效果
                treePositions[i*3 + 1] += Math.sin(time + treePositions[i*3]) * 0.001;
            }
            treeParticles.geometry.attributes.position.needsUpdate = true;
            
            // 星星闪烁
            starParticles.scale.setScalar(1 + Math.sin(time*5) * 0.2);

            renderer.render(scene, camera);
        }
        animate();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
