<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ„ ç’€ç’¨æ˜Ÿæ²³åœ£è¯æ ‘</title>
    <style>
        /* æ·±é‚ƒçš„å®‡å®™èƒŒæ™¯ï¼Œè¡¬æ‰˜å‘å…‰ç²’å­ */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            background: radial-gradient(circle at center, #1a1020 0%, #000000 100%); 
        }
        #debug {
            position: absolute; top: 0; left: 0; color: red; z-index: 100; 
            background: rgba(0,0,0,0.8); padding: 10px; display: none;
        }
        #title {
            position: absolute; top: 12%; width: 100%; text-align: center;
            color: #ffd700; font-size: 26px; font-weight: bold; letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(255, 215, 0, 1.0); pointer-events: none;
            font-family: "Times New Roman", serif;
        }
        #tips {
            position: absolute; bottom: 10%; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.7); font-size: 14px; pointer-events: none;
            text-shadow: 0 0 5px #000;
        }
    </style>
    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="debug"></div>
    <div id="title">MERRY CHRISTMAS</div>
    <div id="tips">âœ¨ ç‚¹å‡»å±å¹•èšæ‹¢/æ•£å¼€ | æ»‘åŠ¨æ—‹è½¬ âœ¨</div>
    <div id="canvas-container" style="width:100%; height:100%; position:absolute; top:0; left:0; z-index:1;"></div>

    <script>
        window.onerror = function(msg) {
            const debugEl = document.getElementById('debug');
            debugEl.style.display = 'block';
            debugEl.innerHTML += "é”™è¯¯: " + msg + "<br>";
        };

        try {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 16);

            // å¼€å¯ç‰©ç†ä¸Šæ­£ç¡®çš„å…‰ç…§è®¡ç®—
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.physicallyCorrectLights = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // --- å¥¢åç¯å…‰ç³»ç»Ÿ ---
            const ambientLight = new THREE.AmbientLight(0x444444, 0.5);
            scene.add(ambientLight);

            // ä¸»é‡‘è‰²å°„ç¯
            const mainLight = new THREE.DirectionalLight(0xffd700, 3.0);
            mainLight.position.set(5, 15, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            
            // å½©è‰²è¡¥å…‰ï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ
            const redLight = new THREE.PointLight(0xff0000, 1.5, 20);
            redLight.position.set(-10, 5, 5);
            scene.add(redLight);
            const blueLight = new THREE.PointLight(0x0000ff, 1.5, 20);
            blueLight.position.set(10, -5, 5);
            scene.add(blueLight);

            // --- ä¸°å¯Œçš„æè´¨åº“ (å¸¦è‡ªå‘å…‰!) ---
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800, emissiveIntensity: 0.4, metalness: 1.0, roughness: 0.1 }), // é‡‘
                new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 }), // çº¢
                new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x008800, emissiveIntensity: 0.4, metalness: 0.8, roughness: 0.2 }), // ç»¿
                new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x0044aa, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 }), // è“
                new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xaaaaaa, emissiveIntensity: 0.3, metalness: 0.7, roughness: 0.3 })  // é“¶
            ];

            // --- ä¸°å¯Œçš„å½¢çŠ¶åº“ ---
            const geometries = [
                new THREE.BoxGeometry(0.6, 0.6, 0.6),
                new THREE.SphereGeometry(0.4, 16, 16),
                new THREE.OctahedronGeometry(0.5, 0), // é’»çŸ³
                new THREE.IcosahedronGeometry(0.5, 0), // å®çŸ³
            ];
            const starGeo = new THREE.OctahedronGeometry(1.5, 0); // é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ

            // --- ç²’å­ç³»ç»Ÿ ---
            const group = new THREE.Group();
            scene.add(group);
            const allMesh = [];
            const count = 1200; // æ•°é‡ç¿»å€ï¼

            for (let i = 0; i < count; i++) {
                // éšæœºé€‰æ‹©å½¢çŠ¶å’Œæè´¨
                const geo = geometries[Math.floor(Math.random() * geometries.length)];
                const mat = materials[Math.floor(Math.random() * materials.length)].clone(); // clone ä»¥ä¾¿å•ç‹¬æ§åˆ¶é—ªçƒ
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true; mesh.receiveShadow = true;
                
                // éšæœºå¤§å°
                const s = Math.random() * 0.5 + 0.3;
                mesh.scale.set(s,s,s);

                // ä½ç½®Aï¼šçˆ†ç‚¸æ•£å¼€
                const r = 15;
                mesh.userData.posOpen = new THREE.Vector3(
                    (Math.random()-0.5)*r*2.5, (Math.random()-0.5)*r*2.5, (Math.random()-0.5)*r*2
                );

                // ä½ç½®Bï¼šèšæ‹¢æˆæ ‘
                const p = i / count; 
                const angle = p * Math.PI * 30 + i * 0.05;
                const radius = (1 - p) * 6.5;
                mesh.userData.posTree = new THREE.Vector3(
                    Math.cos(angle)*radius, p * 13 - 6.5, Math.sin(angle)*radius
                );

                mesh.position.copy(mesh.userData.posOpen);
                
                // éšæœºå‚æ•°ç”¨äºé—ªçƒåŠ¨ç”»
                mesh.userData.randomPhase = Math.random() * Math.PI * 2;
                mesh.userData.rotSpeed = { x: Math.random()*0.03, y: Math.random()*0.03 };

                group.add(mesh);
                allMesh.push(mesh);
            }

            // é¡¶éƒ¨è¶…çº§å¤§æ˜Ÿæ˜Ÿ
            const topStarMat = new THREE.MeshStandardMaterial({ 
                color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1, metalness: 1, roughness: 0 
            });
            const topStar = new THREE.Mesh(starGeo, topStarMat);
            topStar.userData.posOpen = new THREE.Vector3(0, 18, 0);
            topStar.userData.posTree = new THREE.Vector3(0, 7.5, 0);
            topStar.position.copy(topStar.userData.posOpen);
            group.add(topStar);
            allMesh.push(topStar);

            // --- äº¤äº’ä¸åŠ¨ç”» ---
            let isTree = false;
            let progress = 0;
            
            document.body.addEventListener('click', () => { isTree = !isTree; });
            document.body.addEventListener('touchstart', (e) => {
                if(e.changedTouches.length === 1 && Math.abs(e.changedTouches[0].clientX - lastX) < 5) {
                     isTree = !isTree;
                }
            }, {passive: true});

            let lastX = 0; let rotY = 0;
            document.body.addEventListener('touchstart', (e) => { lastX = e.touches[0].clientX; }, {passive: true});
            document.body.addEventListener('touchmove', (e) => {
                rotY += (e.touches[0].clientX - lastX) * 0.008; lastX = e.touches[0].clientX;
            }, {passive: true});

            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.05;
                progress += ((isTree ? 1 : 0) - progress) * 0.04;

                allMesh.forEach(m => {
                    m.position.lerpVectors(m.userData.posOpen, m.userData.posTree, progress);
                    m.rotation.x += m.userData.rotSpeed.x;
                    m.rotation.y += m.userData.rotSpeed.y;
                    
                    // é—ªçƒæ•ˆæœï¼šåŠ¨æ€æ”¹å˜è‡ªå‘å…‰å¼ºåº¦
                    if(m.material.emissiveIntensity) {
                        m.material.emissiveIntensity = 0.3 + Math.sin(time + m.userData.randomPhase) * 0.2;
                    }
                });
                
                topStar.rotation.y += 0.02;
                topStar.material.emissiveIntensity = 1 + Math.sin(time*2)*0.3; // å¤§æ˜Ÿæ˜Ÿé—ªå¾—æ›´äº®

                group.rotation.y += 0.001;
                group.rotation.y += (rotY - group.rotation.y) * 0.1;

                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

        } catch (err) {
            document.getElementById('debug').style.display = 'block';
            document.getElementById('debug').innerHTML += "JSè¿è¡Œé”™è¯¯: " + err.message;
        }
    </script>
</body>
</html>
